// ============================================================================
// IFL ASM Export — sjasmplus-compatible ASM source for 8x2 multicolor
// ============================================================================

/**
 * 8x2 Multicolor - Dual-screen interlace (from zxpress.ru)
 *
 * Algorithm:
 * - BC=#7FFD, D=#1F (show bank 7), E=#17 (show bank 5)
 * - Screen 1 shows even rows (0,2,4...), Screen 2 shows odd rows (1,3,5...)
 * - 96 flips per frame: OUT(C),D/E to flip, then write to OTHER screen
 * - OUT (C),D/E (12T) + 16×POP+LD (416T) + DS 5 (20T) = 448T per row
 *
 * Pentagon 128K timing (224T/line, 320 lines):
 * - Each attr row = 2 scanlines = 448T
 * - No beam racing: always write to screen not being displayed
 */
function generateIflAsm(iflData, baseName = 'ifl', embedData = true) {
  if (!iflData || iflData.length < 9216) return null;

  const bitmap = Array.from(iflData.slice(0, 6144));
  const attrsRaw = Array.from(iflData.slice(6144, 9216));

  // Reorder attrs for interlaced dual-screen:
  // While showing row N, write row N+1 to the other screen
  // Order: row1, row2, row3, ..., row95, row0
  const attrs = [];
  for (let row = 1; row <= 96; row++) {
    const srcRow = row % 96;
    for (let col = 0; col < 32; col++) {
      attrs.push(attrsRaw[srcRow * 32 + col]);
    }
  }

  function formatDbLines(data, bytesPerLine) {
    const lines = [];
    for (let i = 0; i < data.length; i += bytesPerLine) {
      const chunk = data.slice(i, Math.min(i + bytesPerLine, data.length));
      lines.push('    DB ' + chunk.map(b => '#' + b.toString(16).toUpperCase().padStart(2, '0')).join(','));
    }
    return lines.join('\n');
  }

  const asm = [];

  asm.push('; ============================================================================');
  asm.push('; IFL 8x2 Multicolor viewer for Pentagon 128K');
  asm.push('; Generated by SpectraLab');
  asm.push('; ============================================================================');
  asm.push('; Dual-screen interlace technique (from zxpress.ru)');
  asm.push('; BC=#7FFD, D=#1F (show screen 2), E=#17 (show screen 1)');
  asm.push('; Even rows: show screen 1, write to screen 2 (#D800)');
  asm.push('; Odd rows: show screen 2, write to screen 1 (#5800)');
  asm.push('; OUT(C),r (12T) + NOP (4T) + 16×POP+LD (416T) + DS 4 (16T) = 448T per row');
  asm.push('; ============================================================================');
  asm.push('');
  asm.push('    DEVICE ZXSPECTRUM128');
  asm.push('    ORG #6000');
  asm.push('');

  asm.push('Start:');
  asm.push('    DI');
  asm.push('');
  asm.push('    ; Page bank 7 at #C000 for second screen access');
  asm.push('    LD BC,#7FFD');
  asm.push('    LD A,#17              ; Bank 7 at #C000, show screen 1');
  asm.push('    OUT (C),A');
  asm.push('');

  if (!embedData) {
    // Add attr reordering code for INCBIN mode
    asm.push('    ; Reorder attrs: row1..row95,row0 (for write-ahead interlace)');
    asm.push('    LD HL,IflData + 6144 + 32   ; Source: row 1');
    asm.push('    LD DE,AttrData              ; Dest: start of buffer');
    asm.push('    LD BC,3040                  ; 95 rows × 32 bytes');
    asm.push('    LDIR');
    asm.push('    LD HL,IflData + 6144        ; Source: row 0');
    asm.push('    LD BC,32                    ; 1 row × 32 bytes');
    asm.push('    LDIR                        ; DE already at AttrData+3040');
    asm.push('');
  }

  asm.push('    ; Clear attrs on both screens');
  asm.push('    LD HL,#5800');
  asm.push('    LD DE,#5801');
  asm.push('    LD BC,767');
  asm.push('    LD (HL),#00');
  asm.push('    LDIR                  ; HL=#5AFF, BC=0 after');
  asm.push('    LD DE,#DAFF');
  asm.push('    LD B,3                ; BC=768 (C already 0)');
  asm.push('    LDDR                  ; Copy from screen 1 to screen 2');
  asm.push('');

  asm.push('    ; Copy bitmap to BOTH screens');
  if (embedData) {
    asm.push('    LD HL,BitmapData');
  } else {
    asm.push('    LD HL,IflData');
  }
  asm.push('    LD DE,#4000');
  asm.push('    LD BC,6144');
  asm.push('    LDIR                  ; DE=#5800, BC=0 after');
  asm.push('    EX DE,HL');
  asm.push('    DEC HL                ; HL=#57FF');
  asm.push('    LD DE,#D7FF');
  asm.push('    LD B,#18              ; BC=#1800=6144 (C already 0)');
  asm.push('    LDDR                  ; Copy screen 1 to screen 2');
  asm.push('');
  asm.push('    ; Black border');
  asm.push('    XOR A');
  asm.push('    OUT (#FE),A');
  asm.push('');
  asm.push('    ; Setup IM2 interrupt (minimal handler: just RET)');
  asm.push('    LD HL,#FE00');
  asm.push('    LD DE,#FE01');
  asm.push('    LD BC,257');
  asm.push('    LD (HL),#FD');
  asm.push('    LDIR');
  asm.push('    LD A,#C9             ; RET opcode');
  asm.push('    LD (#FDFD),A');
  asm.push('    LD A,#FE');
  asm.push('    LD I,A');
  asm.push('    IM 2');
  asm.push('');
  asm.push('    ; Setup registers for page flipping (preserved across frames)');
  asm.push('    LD BC,#7FFD           ; Paging port');
  asm.push('    LD D,#1F              ; Show screen 2 (bank 7)');
  asm.push('    LD E,#17              ; Show screen 1 (bank 5)');
  asm.push('');

  asm.push('; ============================================================================');
  asm.push('; Main loop - dual screen interlace');
  asm.push('; ============================================================================');
  asm.push('MainLoop:');
  asm.push('    EI');
  asm.push('    HALT                  ; Wait for INT');
  asm.push('    DI');
  asm.push('    LD (SaveSP+1),SP');
  asm.push('');
  asm.push('    ; Delay to paper area: ~17844T');
  asm.push('    ; Using A,H to preserve BC=#7FFD, D=#1F, E=#17');
  asm.push('    LD A,77               ; 7T');
  asm.push('.bdel1:');
  asm.push('    LD H,13               ; 7T');
  asm.push('.bdel2:');
  asm.push('    DEC H                 ; 4T');
  asm.push('    JR NZ,.bdel2          ; 12T/7T');
  asm.push('    DEC A                 ; 4T');
  asm.push('    JR NZ,.bdel1          ; 12T/7T');
  asm.push('    DS 110,0              ; 440T');
  asm.push('');
  asm.push('    LD SP,AttrData');
  asm.push('');
  asm.push('    ; === 96 attr rows: interlaced between two screens ===');
  asm.push('    ; OUT(C),E (show scr1) then write to #D800 (scr2)');
  asm.push('    ; OUT(C),D (show scr2) then write to #5800 (scr1)');
  asm.push('    ; OUT(C),r (12T) + NOP (4T) + 16×POP+LD (416T) + DS 4 (16T) = 448T');
  asm.push('');
  asm.push('    ; 24 char rows × 4 attr rows each = 96 total');
  asm.push('    DUP 24, charRow');
  asm.push('        DUP 4, subRow');
  asm.push('            IF subRow & 1');
  asm.push('                OUT (C),D     ; odd: show scr2, write to scr1');
  asm.push('            ELSE');
  asm.push('                OUT (C),E     ; even: show scr1, write to scr2');
  asm.push('            ENDIF');
  asm.push('            NOP');
  asm.push('            DUP 16, col');
  asm.push('                POP HL');
  asm.push('                IF subRow == 3');
  asm.push('                    IF charRow == 23');
  asm.push('                        LD (#5800 + col * 2),HL           ; wrap to row 0');
  asm.push('                    ELSE');
  asm.push('                        LD (#5800 + (charRow + 1) * 32 + col * 2),HL');
  asm.push('                    ENDIF');
  asm.push('                ELSEIF subRow & 1');
  asm.push('                    LD (#5800 + charRow * 32 + col * 2),HL');
  asm.push('                ELSE');
  asm.push('                    LD (#D800 + charRow * 32 + col * 2),HL');
  asm.push('                ENDIF');
  asm.push('            EDUP');
  asm.push('            DS 4');
  asm.push('        EDUP');
  asm.push('    EDUP');
  asm.push('');
  asm.push('SaveSP:');
  asm.push('    LD SP,0');
  asm.push('    JP MainLoop');
  asm.push('');

  asm.push('; ============================================================================');
  asm.push('; Data');
  asm.push('; ============================================================================');
  asm.push('');

  if (embedData) {
    asm.push('BitmapData:');
    asm.push(formatDbLines(bitmap, 16));
    asm.push('');
    asm.push('; Attribute data: 96 rows × 32 bytes = 3072 bytes');
    asm.push('; Order: row1, row2, ..., row95, row0 (for write-ahead interlace)');
    asm.push('AttrData:');
    asm.push(formatDbLines(attrs, 16));
  } else {
    asm.push('; IFL file: 6144 bytes bitmap + 3072 bytes attrs');
    asm.push('IflData:');
    asm.push(`    INCBIN "${baseName}.ifl"`);
    asm.push('');
    asm.push('; Attribute buffer: reordered at startup (row1..row95,row0)');
    asm.push('AttrData:');
    asm.push('    DS 3072');
  }
  asm.push('');
  asm.push(`    SAVESNA "${baseName}.sna",Start`);

  return { asm: asm.join('\n') };
}

function generateTestIfl() {
  const data = new Uint8Array(9216);
  // White bitmap (all pixels set)
  for (let i = 0; i < 6144; i++) data[i] = 0xFF;
  // Alternating red/blue attrs per row
  for (let row = 0; row < 96; row++) {
    const offset = 6144 + row * 32;
    const color = (row % 2 === 0) ? 0x02 : 0x01; // red=2, blue=1
    for (let col = 0; col < 32; col++) data[offset + col] = color;
  }
  return data;
}

function downloadTestIfl() {
  const testData = generateTestIfl();
  const blob = new Blob([testData], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'timing-test.ifl';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function exportIflAsm() {
  if (currentFormat !== FORMAT.IFL || !screenData || screenData.length < 9216) {
    alert('Export ASM is only available for IFL (8x2 multicolor) format.');
    return;
  }

  let baseName = 'ifl';
  if (currentFileName) {
    const fileName = currentFileName.includes('/')
      ? currentFileName.substring(currentFileName.lastIndexOf('/') + 1)
      : currentFileName;
    baseName = fileName.replace(/\.[^.]+$/, '');
  }

  const embedChk = document.getElementById('editorEmbedDataChk');
  const embedData = embedChk ? embedChk.checked : true;

  const result = generateIflAsm(screenData, baseName, embedData);
  if (!result) return;

  const blob = new Blob([result.asm], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = baseName + '.asm';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
